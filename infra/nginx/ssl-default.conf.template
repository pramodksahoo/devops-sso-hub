# Enhanced NGINX Configuration with SSL Support
# Supports both HTTP and HTTPS based on available certificates

# Upstream backends
upstream auth_bff_backend {
    server auth-bff:3002;
    keepalive 32;
}

upstream user_service_backend {
    server user-service:3003;
    keepalive 32;
}

upstream tools_service_backend {
    server tools-service:3004;
    keepalive 32;
}

upstream catalog_backend {
    server catalog:3006;
    keepalive 32;
}

upstream frontend_backend {
    server frontend:3000;
    keepalive 32;
}

upstream keycloak_backend {
    server keycloak:8080;
    keepalive 32;
}

# Rate limiting zones
limit_req_zone $binary_remote_addr zone=auth_limit:10m rate=10r/m;
limit_req_zone $binary_remote_addr zone=api_limit:10m rate=100r/m;

# SSL Configuration Map
map $ssl_preread_server_name $backend_pool {
    default frontend_backend;
}

# Common server configuration block
server {
    # HTTP Configuration (always enabled)
    listen 80;
    
    # HTTPS Configuration (conditional based on SSL certificates)
    listen 443 ssl http2;
    
    server_name ${EXTERNAL_HOST} localhost;
    
    # SSL Configuration
    ssl_certificate /etc/nginx/ssl/server.crt;
    ssl_certificate_key /etc/nginx/ssl/server.key;
    ssl_dhparam /etc/nginx/ssl/dhparam.pem;
    
    # Modern SSL Configuration
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;
    ssl_session_cache shared:SSL:50m;
    ssl_session_timeout 1d;
    ssl_session_tickets off;
    
    # OCSP stapling
    ssl_stapling on;
    ssl_stapling_verify on;
    
    # Security headers (conditional for HTTPS)
    add_header X-Frame-Options "DENY" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    
    # HSTS only for HTTPS
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;

    # HTTP to HTTPS redirect (conditional)
    if ($scheme != "https") {
        set $redirect_https 0;
    }
    
    # Enable redirect only if EXTERNAL_PROTOCOL is https
    if ($http_x_forwarded_proto = "https") {
        set $redirect_https 1;
    }
    
    # Skip redirect for health checks and well-known paths
    if ($request_uri ~ "^/(health|\.well-known)") {
        set $redirect_https 0;
    }

    # Health check endpoint (no auth required, works on both HTTP/HTTPS)
    location /health {
        access_log off;
        return 200 "OK\n";
        add_header Content-Type text/plain;
    }

    # Public endpoints (no auth required)
    location ~ ^/(favicon\.ico|robots\.txt|\.well-known) {
        proxy_pass http://frontend_backend;
        include /etc/nginx/proxy_params;
    }

    # OIDC Authentication callback
    location /auth/callback {
        limit_req zone=auth_limit burst=5 nodelay;
        
        access_by_lua_block {
            local oidc = require("resty.openidc")
            local opts = {
                discovery = "${OIDC_DISCOVERY_URL}",
                client_id = "${OIDC_CLIENT_ID}",
                client_secret = "${OIDC_CLIENT_SECRET}",
                redirect_uri = "${OIDC_REDIRECT_URI}",
                scope = "${OIDC_SCOPE}",
                session_contents = {id_token=true},
                logout_path = "${OIDC_LOGOUT_PATH}",
                token_endpoint_auth_method = "client_secret_post"
            }
            
            local res, err = oidc.authenticate(opts)
            if err then
                ngx.log(ngx.ERR, "OIDC authentication failed: ", err)
                ngx.status = 500
                ngx.say("Authentication failed")
                ngx.exit(500)
            end
            
            -- Store user information in session
            ngx.var.remote_user = res.id_token.sub
            ngx.var.remote_user_email = res.id_token.email
            ngx.var.remote_user_name = res.id_token.name or res.id_token.preferred_username
            ngx.var.remote_user_groups = res.id_token.groups or {}
        }
        
        return 302 /dashboard;
    }

    # OIDC Logout
    location /auth/logout {
        access_by_lua_block {
            local oidc = require("resty.openidc")
            local scheme = ngx.var.scheme or "http"
            local host = ngx.var.host
            local port = ""
            
            -- Determine redirect URL based on scheme
            local redirect_base = scheme .. "://" .. host
            if scheme == "https" and ngx.var.server_port ~= "443" then
                redirect_base = redirect_base .. ":" .. ngx.var.server_port
            elseif scheme == "http" and ngx.var.server_port ~= "80" then
                redirect_base = redirect_base .. ":" .. ngx.var.server_port
            end
            
            local opts = {
                discovery = "${OIDC_DISCOVERY_URL}",
                client_id = "${OIDC_CLIENT_ID}",
                logout_path = "${OIDC_LOGOUT_PATH}",
                post_logout_redirect_uri = redirect_base .. "/"
            }
            oidc.logout(opts)
        }
    }

    # Authentication routes - proxy to Auth-BFF
    location /auth/ {
        limit_req zone=auth_limit burst=10 nodelay;
        
        proxy_pass http://auth_bff_backend;
        include /etc/nginx/proxy_params;
    }

    # Keycloak routes (public access) - Updated for proper scheme handling
    location /realms/ {
        proxy_pass http://keycloak_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # Handle redirects properly for both HTTP and HTTPS
        set $redirect_scheme $scheme;
        set $redirect_port "";
        
        if ($scheme = "https") {
            set $redirect_port ":443";
        }
        if ($scheme = "http") {
            set $redirect_port ":80";
        }
        if ($server_port = "443") {
            set $redirect_port "";
        }
        if ($server_port = "80") {
            set $redirect_port "";
        }
        
        proxy_redirect http://keycloak:8080 $redirect_scheme://$host$redirect_port;
        proxy_redirect https://keycloak:8080 $redirect_scheme://$host$redirect_port;
    }

    # Keycloak admin (protected)
    location /admin/ {
        # OIDC authentication required
        access_by_lua_block {
            local oidc = require("resty.openidc")
            local opts = {
                discovery = "${OIDC_DISCOVERY_URL}",
                client_id = "${OIDC_CLIENT_ID}",
                client_secret = "${OIDC_CLIENT_SECRET}",
                redirect_uri = "${OIDC_REDIRECT_URI}",
                scope = "${OIDC_SCOPE}",
                session_contents = {id_token=true}
            }
            
            local res, err = oidc.authenticate(opts)
            if err then
                ngx.log(ngx.ERR, "OIDC authentication failed: ", err)
                return ngx.exit(401)
            end
            
            -- Check admin role
            local groups = res.id_token.groups or {}
            local is_admin = false
            for i, group in ipairs(groups) do
                if group == "admins" or group == "/admins" then
                    is_admin = true
                    break
                end
            end
            
            if not is_admin then
                ngx.log(ngx.WARN, "Access denied to admin panel for user: ", res.id_token.sub)
                return ngx.exit(403)
            end
        }
        
        proxy_pass http://keycloak_backend;
        include /etc/nginx/proxy_params;
    }

    # API routes (protected with identity headers)
    location /api/ {
        limit_req zone=api_limit burst=20 nodelay;
        
        # OIDC authentication and identity header injection
        access_by_lua_block {
            local oidc = require("resty.openidc")
            local hmac = require("resty.hmac")
            local str = require("resty.string")
            
            local opts = {
                discovery = "${OIDC_DISCOVERY_URL}",
                client_id = "${OIDC_CLIENT_ID}",
                client_secret = "${OIDC_CLIENT_SECRET}",
                redirect_uri = "${OIDC_REDIRECT_URI}",
                scope = "${OIDC_SCOPE}",
                session_contents = {id_token=true}
            }
            
            local res, err = oidc.authenticate(opts)
            if err then
                ngx.log(ngx.ERR, "OIDC authentication failed: ", err)
                return ngx.exit(401)
            end
            
            -- Extract user information
            local user_sub = res.id_token.sub or ""
            local user_email = res.id_token.email or ""
            local user_name = res.id_token.name or res.id_token.preferred_username or ""
            local user_groups = table.concat(res.id_token.groups or {}, ",")
            local user_roles = table.concat(res.id_token.realm_access and res.id_token.realm_access.roles or {}, ",")
            
            -- Create HMAC signature
            local secret = "${IDENTITY_HEADER_SECRET}"
            local payload = user_sub .. "|" .. user_email .. "|" .. user_name .. "|" .. user_groups .. "|" .. user_roles
            local signature = hmac:new(secret, hmac.ALGOS.SHA256):final(payload)
            local signature_hex = str.to_hex(signature)
            
            -- Set identity headers
            ngx.req.set_header("X-User-Sub", user_sub)
            ngx.req.set_header("X-User-Email", user_email)
            ngx.req.set_header("X-User-Name", user_name)
            ngx.req.set_header("X-User-Groups", user_groups)
            ngx.req.set_header("X-User-Roles", user_roles)
            ngx.req.set_header("X-User-Signature", signature_hex)
        }
        
        # Route to appropriate service based on path
        location /api/users/ {
            proxy_pass http://user_service_backend/;
            include /etc/nginx/proxy_params;
        }
        
        location /api/tools/ {
            proxy_pass http://catalog_backend/api/tools/;
            include /etc/nginx/proxy_params;
        }
        
        location /api/catalog/ {
            proxy_pass http://catalog_backend/api/;
            include /etc/nginx/proxy_params;
        }
        
        # Default API routing
        proxy_pass http://auth_bff_backend;
        include /etc/nginx/proxy_params;
    }

    # Frontend routes - serve React app for SPA routing
    location ~ ^/(dashboard|tools|profile|admin|admin-tools|launchpad|health|webhooks|audit|analytics|ldap|provisioning)(/.*)?$ {
        # Optional OIDC authentication (don't fail if not authenticated)
        access_by_lua_block {
            local oidc = require("resty.openidc")
            local opts = {
                discovery = "${OIDC_DISCOVERY_URL}",
                client_id = "${OIDC_CLIENT_ID}",
                client_secret = "${OIDC_CLIENT_SECRET}",
                redirect_uri = "${OIDC_REDIRECT_URI}",
                scope = "${OIDC_SCOPE}",
                session_contents = {id_token=true}
            }
            
            -- Try to authenticate but don't fail if unauthenticated
            local res, err = oidc.introspect(opts)
            if res and res.active then
                ngx.req.set_header("X-User-Sub", res.sub or "")
                ngx.req.set_header("X-User-Email", res.email or "")
                ngx.req.set_header("X-User-Authenticated", "true")
            else
                ngx.req.set_header("X-User-Authenticated", "false")
            end
        }
        
        proxy_pass http://frontend_backend;
        include /etc/nginx/proxy_params;
        
        # WebSocket support
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }

    # Frontend root - with optional authentication
    location / {
        # Optional OIDC authentication (don't fail if not authenticated)
        access_by_lua_block {
            local oidc = require("resty.openidc")
            local opts = {
                discovery = "${OIDC_DISCOVERY_URL}",
                client_id = "${OIDC_CLIENT_ID}",
                client_secret = "${OIDC_CLIENT_SECRET}",
                redirect_uri = "${OIDC_REDIRECT_URI}",
                scope = "${OIDC_SCOPE}",
                session_contents = {id_token=true}
            }
            
            -- Try to authenticate but don't fail if unauthenticated
            local res, err = oidc.introspect(opts)
            if res and res.active then
                ngx.req.set_header("X-User-Sub", res.sub or "")
                ngx.req.set_header("X-User-Email", res.email or "")
                ngx.req.set_header("X-User-Authenticated", "true")
            else
                ngx.req.set_header("X-User-Authenticated", "false")
            end
        }
        
        proxy_pass http://frontend_backend;
        include /etc/nginx/proxy_params;
        
        # WebSocket support
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }

    # Error pages
    error_page 500 502 503 504 /50x.html;
    location = /50x.html {
        root /usr/local/openresty/nginx/html;
    }
}